"use strict";
/* istanbul ignore file */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerenityReporterForMocha = void 0;
const events_1 = require("@serenity-js/core/lib/events");
const io_1 = require("@serenity-js/core/lib/io");
const model_1 = require("@serenity-js/core/lib/model");
const mocha_1 = require("mocha");
const mappers_1 = require("./mappers");
const OutcomeRecorder_1 = require("./OutcomeRecorder");
/**
 * @package
 */
class SerenityReporterForMocha extends mocha_1.reporters.Base {
    /**
     * @param {Serenity} serenity
     * @param {mocha~Runner} runner
     * @param {mocha~MochaOptions} options
     */
    constructor(serenity, runner, options) {
        super(runner, options);
        this.serenity = serenity;
        this.testMapper = new mappers_1.MochaTestMapper();
        this.outcomeMapper = new mappers_1.MochaOutcomeMapper();
        this.recorder = new OutcomeRecorder_1.OutcomeRecorder();
        this.suiteIds = [];
        this.currentSceneId = undefined;
        runner.on(mocha_1.Runner.constants.EVENT_RUN_BEGIN, () => {
            this.emit(new events_1.TestRunStarts(this.serenity.currentTime()));
        });
        runner.on(mocha_1.Runner.constants.EVENT_SUITE_BEGIN, (suite) => {
            if (suite.root === false) {
                this.announceSuiteStartsFor(suite);
            }
        });
        runner.on(mocha_1.Runner.constants.EVENT_SUITE_END, (suite) => {
            if (suite.root === false) {
                this.announceSuiteFinishedFor(suite);
            }
        });
        runner.on(mocha_1.Runner.constants.EVENT_TEST_BEGIN, (test) => {
            this.recorder.started(test);
            this.announceSceneStartsFor(test);
        });
        runner.on(mocha_1.Runner.constants.EVENT_TEST_PASS, (test) => {
            this.announceRetryIfNeeded(test);
            this.recorder.finished(test.ctx ? test.ctx.currentTest : test, this.outcomeMapper.outcomeOf(test));
        });
        runner.on(mocha_1.Runner.constants.EVENT_TEST_FAIL, (test, error) => {
            this.announceRetryIfNeeded(test);
            this.recorder.finished(test.ctx ? test.ctx.currentTest : test, this.outcomeMapper.outcomeOf(test, error));
        });
        runner.on(mocha_1.Runner.constants.EVENT_TEST_RETRY, (test, error) => {
            this.announceRetryIfNeeded(test);
            this.recorder.finished(!!test.ctx && test.ctx.currentTest ? test.ctx.currentTest : test, this.outcomeMapper.outcomeOf(test, error));
        });
        const announceSceneFinishedFor = SerenityReporterForMocha.prototype.announceSceneFinishedFor.bind(this);
        runner.suite.afterEach('Serenity/JS', function () {
            return announceSceneFinishedFor(this.currentTest, this.test);
        });
        // https://github.com/cypress-io/cypress/issues/7562
        runner.on('test:after:run', (test) => {
            return announceSceneFinishedFor(test, test);
        });
        // Tests without body don't trigger the above custom afterEach hook
        runner.on(mocha_1.Runner.constants.EVENT_TEST_PENDING, (test) => {
            if (!test.fn) {
                this.announceSceneSkippedFor(test);
            }
        });
    }
    done(failures, fn) {
        this.emit(new events_1.TestRunFinishes(this.serenity.currentTime()));
        this.serenity.waitForNextCue()
            .then(() => {
            this.emit(new events_1.TestRunFinished(this.serenity.currentTime()));
        })
            .catch(error => {
            this.emit(new events_1.TestRunFinished(this.serenity.currentTime())); // todo: consider adding outcome to TestRunFinished
        })
            .then(() => fn(failures));
    }
    announceSuiteStartsFor(suite) {
        const suiteId = model_1.CorrelationId.create();
        this.suiteIds.push(suiteId);
        const details = new model_1.TestSuiteDetails(new model_1.Name(suite.title), 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        new io_1.FileSystemLocation(io_1.Path.from(suite.file)), // all suites except for the root suite should have .file property set
        suiteId);
        this.emit(new events_1.TestSuiteStarts(details, this.serenity.currentTime()));
    }
    announceSuiteFinishedFor(suite) {
        const details = new model_1.TestSuiteDetails(new model_1.Name(suite.title), 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        new io_1.FileSystemLocation(io_1.Path.from(suite.file)), // all suites except for the root suite should have .file property set
        this.suiteIds.pop());
        const outcomes = suite.tests.map(test => this.recorder.outcomeOf(test) || this.outcomeMapper.outcomeOf(test));
        const worstOutcome = outcomes.reduce((worstSoFar, outcome) => outcome.isWorseThan(worstSoFar)
            ? outcome
            : worstSoFar, new model_1.ExecutionSuccessful());
        this.emit(new events_1.TestSuiteFinished(details, worstOutcome, this.serenity.currentTime()));
    }
    announceSceneStartsFor(test) {
        this.currentSceneId = this.serenity.assignNewSceneId();
        const scenario = this.testMapper.detailsOf(test);
        this.emit(new events_1.SceneStarts(this.currentSceneId, scenario, this.serenity.currentTime()), new events_1.SceneTagged(this.currentSceneId, new model_1.FeatureTag(this.testMapper.featureNameFor(test)), this.serenity.currentTime()), new events_1.TestRunnerDetected(this.currentSceneId, new model_1.Name('Mocha'), this.serenity.currentTime()));
    }
    announceSceneFinishedFor(test, runnable) {
        const scenario = this.testMapper.detailsOf(test), outcome = this.recorder.outcomeOf(test) || this.outcomeMapper.outcomeOf(test);
        this.emit(new events_1.SceneFinishes(this.currentSceneId, scenario, outcome, this.serenity.currentTime()));
        return this.serenity.waitForNextCue()
            .then(() => {
            this.emit(new events_1.SceneFinished(this.currentSceneId, scenario, outcome, this.serenity.currentTime()));
            this.recorder.erase(test);
        }, error => {
            this.emit(new events_1.SceneFinished(this.currentSceneId, scenario, new model_1.ExecutionFailedWithError(error), this.serenity.currentTime()));
            this.recorder.erase(test);
            // re-throwing an error here would cause Mocha to halt test suite, which we don't want to do
            // https://github.com/mochajs/mocha/issues/1635
            runnable.error(error);
        });
    }
    announceSceneSkippedFor(test) {
        const scenario = this.testMapper.detailsOf(test), outcome = this.outcomeMapper.outcomeOf(test);
        this.announceSceneStartsFor(test);
        this.emit(new events_1.SceneFinishes(this.currentSceneId, scenario, outcome, this.serenity.currentTime()), new events_1.SceneFinished(this.currentSceneId, scenario, outcome, this.serenity.currentTime()));
    }
    announceRetryIfNeeded(test) {
        if (!this.isRetriable(test)) {
            return void 0;
        }
        this.emit(new events_1.RetryableSceneDetected(this.currentSceneId), new events_1.SceneTagged(this.currentSceneId, new model_1.ArbitraryTag('retried'), this.serenity.currentTime()));
        if (this.currentRetryOf(test) > 0) {
            this.emit(new events_1.SceneTagged(this.currentSceneId, new model_1.ExecutionRetriedTag(this.currentRetryOf(test)), this.serenity.currentTime()));
        }
    }
    isRetriable(test) {
        return test.retries() >= 0;
    }
    currentRetryOf(test) {
        return test.currentRetry();
    }
    emit(...events) {
        events.forEach(event => this.serenity.announce(event));
    }
}
exports.SerenityReporterForMocha = SerenityReporterForMocha;
//# sourceMappingURL=SerenityReporterForMocha.js.map