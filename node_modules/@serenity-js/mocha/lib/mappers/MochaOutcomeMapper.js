"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MochaOutcomeMapper = void 0;
const core_1 = require("@serenity-js/core");
const model_1 = require("@serenity-js/core/lib/model");
/**
 * @package
 */
class MochaOutcomeMapper {
    outcomeOf(test, maybeError) {
        const error = maybeError || test.err;
        switch (true) {
            case !!error && this.isGoingToBeRetried(test):
                return new model_1.ExecutionIgnored(error);
            case !!error && this.isAssertionError(error):
                return new model_1.ExecutionFailedWithAssertionError(error);
            case !!error && error instanceof core_1.TestCompromisedError:
                return new model_1.ExecutionCompromised(error);
            case !!error:
                return new model_1.ExecutionFailedWithError(error);
            case test.isPending() && !!test.fn:
                return new model_1.ExecutionSkipped();
            case test.isPending() && !test.fn:
                return new model_1.ImplementationPending(new core_1.ImplementationPendingError(`Scenario not implemented`));
            default:
                return new model_1.ExecutionSuccessful();
        }
    }
    isGoingToBeRetried(test) {
        return !test.isPassed()
            && !test.isFailed()
            && !test.isPending()
            && test.currentRetry() < test.retries();
    }
    isAssertionError(error) {
        return error instanceof core_1.AssertionError
            || this.looksLikeAnAssertionError(error);
    }
    looksLikeAnAssertionError(error) {
        return /^AssertionError/.test(error.name) // eslint-disable-line unicorn/prefer-string-starts-ends-with
            && Object.prototype.hasOwnProperty.call(error, 'expected')
            && Object.prototype.hasOwnProperty.call(error, 'actual');
    }
}
exports.MochaOutcomeMapper = MochaOutcomeMapper;
//# sourceMappingURL=MochaOutcomeMapper.js.map